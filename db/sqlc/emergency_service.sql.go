// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: emergency_service.sql

package db

import (
	"context"
)

const createEmergencyService = `-- name: CreateEmergencyService :one
INSERT INTO emergency_service (
  service_name,
  contact_detail
) VALUES (
  $1, $2
) RETURNING id, service_name, contact_detail, created_at
`

type CreateEmergencyServiceParams struct {
	ServiceName   string `json:"service_name"`
	ContactDetail string `json:"contact_detail"`
}

func (q *Queries) CreateEmergencyService(ctx context.Context, arg CreateEmergencyServiceParams) (EmergencyService, error) {
	row := q.db.QueryRowContext(ctx, createEmergencyService, arg.ServiceName, arg.ContactDetail)
	var i EmergencyService
	err := row.Scan(
		&i.ID,
		&i.ServiceName,
		&i.ContactDetail,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEmergencyService = `-- name: DeleteEmergencyService :exec
DELETE FROM emergency_service WHERE id =$1
`

func (q *Queries) DeleteEmergencyService(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEmergencyService, id)
	return err
}

const listEmergencyService = `-- name: ListEmergencyService :many
SELECT id, service_name, contact_detail, created_at FROM emergency_service
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListEmergencyServiceParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListEmergencyService(ctx context.Context, arg ListEmergencyServiceParams) ([]EmergencyService, error) {
	rows, err := q.db.QueryContext(ctx, listEmergencyService, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EmergencyService{}
	for rows.Next() {
		var i EmergencyService
		if err := rows.Scan(
			&i.ID,
			&i.ServiceName,
			&i.ContactDetail,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
